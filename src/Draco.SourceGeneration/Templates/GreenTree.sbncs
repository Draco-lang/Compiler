namespace Draco.Compiler.Internal.Syntax;

{{include 'Utils.sbncs'}}
{{include 'Tree.sbncs'}}

{{for $node in Nodes}}
    /// <summary>
    /// {{$node.Documentation}}
    /// </summary>
    internal {{class_header($node)}}
    {
        {{for $field in $node.Fields}}
            {{field_prefix($field)}} { get; }
        {{end}}

        {{children($node)}}

        {{protected_public($node)}} {{$node.Name}}(
            {{wrap separated(', ', $node.Fields)}}
                {{$element.Type}} {{camel_case($element.Name)}}
            {{end}}
        )
        {
            {{for $element in $node.Fields}}
                this.{{$element.Name}} = {{camel_case($element.Name)}};
            {{end}}
        }

        {{if $node.IsAbstract}}
            public abstract Api.Syntax.{{$node.Name}} ToRedNode(SyntaxTree tree, Api.Syntax.{{Root.Name}}? parent);
        {{else}}
            public override Api.Syntax.{{$node.Name}} ToRedNode(SyntaxTree tree, Api.Syntax.{{Root.Name}}? parent) =>
                new Api.Syntax.{{$node.Name}}(tree, this, parent);
        {{end}}

        {{if $node.IsAbstract}}
            public abstract TResult Accept(SyntaxVisitor visitor);
            public abstract TResult Accept<TResult>(SyntaxVisitor<TResult> visitor);
        {{else}}
            public override TResult Accept(SyntaxVisitor visitor) =>
                visitor.Visit{{$node.Name}}(this);
            public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor) =>
                visitor.Visit{{$node.Name}}(this);
        {{end}}
    }
{{end}}

/// <summary>
/// Visitor base class for <cref see="{{Root.Name}}"/>.
/// </summary>
internal abstract partial class SyntaxVisitor
{
    {{visitor_functions(Nodes, 'void', null)}}
}

/// <summary>
/// Visitor base class for <cref see="{{Root.Name}}"/>.
/// </summary>
/// <typeparam name="TResult">
/// The return type of the visitor methods.
/// </typeparam>
internal abstract partial class SyntaxVisitor<TResult>
{
    {{visitor_functions(Nodes, 'TResult', 'default!')}}
}
