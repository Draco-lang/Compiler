using System.Collections.Generic;
using System.Collections.Immutable;
using Draco.Compiler.Internal.Solver;
using Draco.Compiler.Internal.Symbols;
using Draco.Compiler.Internal.Types;

namespace Draco.Compiler.Internal.UntypedTree;

{{include 'Utils.sbncs'}}
{{include 'Tree.sbncs'}}

{{func accept_functions(node)}}
    {{if node.IsAbstract && !node.Base}}
        public abstract void Accept(UntypedTreeVisitor visitor);
        public abstract TResult Accept<TResult>(UntypedTreeVisitor<TResult> visitor);
    {{else}}
        public override void Accept(UntypedTreeVisitor visitor) =>
            visitor.Visit{{remove_prefix(node.Name, 'Untyped')}}(this);
        public override TResult Accept<TResult>(UntypedTreeVisitor<TResult> visitor) =>
            visitor.Visit{{remove_prefix(node.Name, 'Untyped')}}(this);
    {{end}}
{{end}}

{{func is_node_name(name)}}
    {{for $n in Nodes}}
        {{if $n.Name == name}}
            {{ret true}}
        {{end}}
    {{end}}
    {{ret false}}
{{end}}

{{func visitor_functions(nodes, return_type, return_value)}}
    {{for $node in nodes}}
        {{if $node.IsAbstract}}
            public {{return_type}} Visit{{remove_prefix($node.Name, 'Untyped')}}({{$node.Name}} node)
            {
                {{if return_value}}
                    return node.Accept(this);
                {{else}}
                    node.Accept(this);
                {{end}}
            }
        {{else}}
            public virtual {{return_type}} Visit{{remove_prefix($node.Name, 'Untyped')}}({{$node.Name}} node)
            {
                {{for $field in $node.Fields}}
                    {{if is_node_name($field.NonNullableType)}}
                        node.{{$field.Name}}{{nullable($field)}}.Accept(this);
                    {{else if $field.IsArray && is_node_name($field.ElementType)}}
                        foreach (var element in node.{{$field.Name}}) element.Accept(this);
                    {{end}}
                {{end}}
                {{if return_value}}
                    return {{return_value}};
                {{end}}
            }
        {{end}}
    {{end}}
{{end}}

#pragma warning disable CS0162
#nullable enable
{{for $node in Nodes}}
    internal {{class_header($node)}}
    {
        {{for $field in $node.Fields}}
            {{field_prefix($field)}} { get; }
        {{end}}

        {{protected_public($node)}} {{$node.Name}}(
            Api.Syntax.SyntaxNode? syntax
            {{for $element in $node.Fields}}
                , {{$element.Type}} {{camel_case($element.Name)}}
            {{end}}
        ) : base(syntax)
        {
            {{for $field in $node.Fields}}
                this.{{$field.Name}} = {{camel_case($field.Name)}};
            {{end}}
        }

        {{if !$node.IsAbstract}}
            public {{$node.Name}} Update(
                {{wrap separated(', ', $node.Fields)}}
                    {{$element.Type}} {{camel_case($element.Name)}}
                {{end}}
            )
            {
                if (true
                    {{for $element in $node.Fields}}
                        && Equals(this.{{$element.Name}}, {{camel_case($element.Name)}})
                    {{end}}
                ) return this;
                else return new {{$node.Name}}(
                    this.Syntax
                    {{for $element in $node.Fields}}
                        , {{camel_case($element.Name)}}
                    {{end}}
                );
            }
        {{end}}

        {{accept_functions($node)}}
    }

    {{if !$node.IsAbstract}}
        internal static partial class UntypedTreeFactory
        {
            public static {{$node.Name}} {{remove_prefix($node.Name, 'Untyped')}}(
                {{wrap separated(', ', $node.Fields)}}
                    {{$element.Type}} {{camel_case($element.Name)}}
                {{end}}
            ) => new {{$node.Name}}(
                null
                {{for $element in $node.Fields}}
                    , {{camel_case($element.Name)}}
                {{end}}
            );
        }
    {{end}}
{{end}}

/// <summary>
/// Visitor base class for <see cref="{{Root.Name}}"/>.
/// </summary>
internal abstract partial class UntypedTreeVisitor
{
    {{visitor_functions(Nodes, 'void', null)}}
}

/// <summary>
/// Visitor base class for <see cref="{{Root.Name}}"/>.
/// </summary>
/// <typeparam name="TResult">
/// The return type of the visitor methods.
/// </typeparam>
internal abstract partial class UntypedTreeVisitor<TResult>
{
    {{visitor_functions(Nodes, 'TResult', 'default!')}}
}

/// <summary>
/// A base class for rewriting <see cref="{{Root.Name}}"/>.
/// </summary>
internal abstract partial class UntypedTreeRewriter : UntypedTreeVisitor<{{Root.Name}}>
{
    {{for $node in Nodes}}
        {{if !$node.IsAbstract}}
            public override {{Root.Name}} Visit{{remove_prefix($node.Name, 'Untyped')}}({{$node.Name}} node)
            {
                {{for $element in $node.Fields}}
                    {{if is_node_name($element.NonNullableType)}}
                        var {{camel_case($element.Name)}} =
                            ({{$element.Type}})node.{{$element.Name}}{{nullable($element)}}.Accept(this);
                    {{else if $element.IsArray && is_node_name($element.ElementType)}}
                        var {{camel_case($element.Name)}} = this.VisitArray(node.{{$element.Name}});
                    {{else}}
                        var {{camel_case($element.Name)}} = node.{{$element.Name}};
                    {{end}}
                {{end}}
                return node.Update(
                    {{wrap separated(', ', $node.Fields)}}
                        {{camel_case($element.Name)}}
                    {{end}}
                );
            }
        {{end}}
    {{end}}
}
#nullable restore
#pragma warning restore CS0162
