@using System.IO.Compression;
@using System.Net.Http
@using System.Net.Http.Json
@using Basic.Reference.Assemblies;
@using Draco.Compiler.Api.Syntax;
@using ICSharpCode.Decompiler.Disassembler;
@using ICSharpCode.Decompiler;
@using ICSharpCode.Decompiler.Metadata;
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.AspNetCore.Components.WebAssembly.Http
@using Microsoft.CodeAnalysis.CSharp;
@using Microsoft.CodeAnalysis;
@using Microsoft.CodeAnalysis.Emit;
@using Microsoft.JSInterop
@using BlazorMonaco
@using System.Text;
@using Draco.Compiler.Api.Scripting;
@using System.Diagnostics.CodeAnalysis;
@using Draco.Compiler.Internal.Codegen;
@using System.Reflection.PortableExecutable;

@inject IJSRuntime JS
@inject NavigationManager NavigationManager

<div class="settings">
    <select @onchange="OnOutputTypeChange">
        <option value="Run">Run</option>
        <option value="CSharp">C#</option>
        <option value="IL">IL</option>
    </select>
</div>
<div class="editors-container">
    <MonacoEditor Id="draco-editor" @ref="DracoEditor" ConstructionOptions="DracoMonacoOptions" OnDidChangeModelContent="CodeChange" />
    <MonacoEditor Id="output-viewer" @ref="OutputViewer" ConstructionOptions="OutputMonacoOptions" />
</div>

@code {
    private MonacoEditor? DracoEditor { get; set; }
    private MonacoEditor? OutputViewer { get; set; }
    private string? SelectedOutputType { get; set; } = "Run";
    private StandaloneEditorConstructionOptions dracoEditorOptions = new StandaloneEditorConstructionOptions
    {
        AutomaticLayout = true,
        Language = "rust",
        Value = @"func main() {
println(""Hello!"");
}"
    };

    private StandaloneEditorConstructionOptions outputEditorOptions = new StandaloneEditorConstructionOptions
    {
        AutomaticLayout = true,
        Language = string.Empty,
        Value = string.Empty,
        ReadOnly = true
    };

    private StandaloneEditorConstructionOptions DracoMonacoOptions(MonacoEditor editor) =>
        dracoEditorOptions;

    private StandaloneEditorConstructionOptions OutputMonacoOptions(MonacoEditor editor) =>
        outputEditorOptions;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        var isDarkMode = await JS.InvokeAsync<bool>("isDarkMode");
        await MonacoEditor.SetTheme(isDarkMode ? "vs-dark" : "vs");
        string uriString = NavigationManager.Uri;
        Uri uri = new Uri(uriString);
        if (!string.IsNullOrWhiteSpace(uri.Fragment))
        {
            string strBuffer = new string(uri.Fragment.Skip(1).ToArray());
            // Convert base64URL to Base64.
            // To be replaced with .NET implementation in .NET 8: https://github.com/dotnet/runtime/issues/1658
            strBuffer = Uri
                .UnescapeDataString(strBuffer)
                .Replace('_', '/')
                .Replace('-', '+')
                .PadRight(4 * ((strBuffer.Length + 3) / 4), '='); // Add Base64 padding.
            var buffer = Convert.FromBase64String(strBuffer); // FromBase64 throws when padding is missing.
            using MemoryStream inBuffer = new MemoryStream(buffer);
            using DeflateStream gzipStream = new DeflateStream(inBuffer, CompressionMode.Decompress);
            using StreamReader outReader = new StreamReader(gzipStream, Encoding.UTF8);
            SelectedOutputType = outReader.ReadLine();
            string code = outReader.ReadToEnd();
            await DracoEditor!.SetValue(code);
        }
        await UpdateOutput();
    }

    private void OnOutputTypeChange(ChangeEventArgs e)
    {
        SelectedOutputType = e.Value!.ToString();
        _ = UpdateOutput(); // awaiting will block UI thread
    }

    private void CodeChange()
    {
        _ = UpdateOutput(); // awaiting will block UI thread.
    }

    private async Task UpdateOutput()
    {
        string code = await DracoEditor!.GetValue();
        using (MemoryStream inBuffer = new MemoryStream())
        using (DeflateStream outStream = new DeflateStream(inBuffer, CompressionLevel.Optimal, true))
        using (StreamWriter writer = new StreamWriter(outStream, Encoding.UTF8, leaveOpen: true))
        {
            writer.WriteLine(SelectedOutputType);
            writer.Write(code);
            writer.Flush();
            inBuffer.Position = 0;
            byte[] buffer = inBuffer.ToArray();
            // Convert base64 to base64URL.
            var hash = Convert.ToBase64String(buffer) 
                .TrimEnd('=')
                .Replace('+', '-')
                .Replace('/', '_');
            await JS.InvokeVoidAsync("setHash", new object[] { hash });
        }
        

        try
        {
            switch (SelectedOutputType)
            {
                case "Run":
                    await ShowRun();
                    break;
                case "CSharp":
                    await ShowCSharp();
                    break;
                case "IL":
                    await ShowIL();
                    break;
                default:
                    throw new InvalidOperationException();
            }
        }
        catch (Exception e)
        {
            await OutputViewer!.SetValue(e.ToString());
        }

        async Task ShowIL()
        {
            outputEditorOptions.Language = "IL";
            await OutputViewer!.UpdateOptions(outputEditorOptions);

            using MemoryStream? inlineDllStream = new MemoryStream();
            if (!ScriptingEngine.CompileToAssembly(code, inlineDllStream)) return;
            inlineDllStream.Position = 0;
            var text = new PlainTextOutput();
            var disassembler = new ReflectionDisassembler(text, default);
            using (var pe = new PEFile("_", inlineDllStream))
            {
                disassembler.WriteAssemblyHeader(pe);
                text.WriteLine();
                disassembler.WriteModuleContents(pe);
            }
            await OutputViewer.SetValue(text.ToString());

        }

        async Task ShowCSharp()
        {
            outputEditorOptions.Language = "csharp";
            await OutputViewer!.UpdateOptions(outputEditorOptions);
            var cSharpCode = ScriptingEngine.CompileToCSharpCode(code);
            await OutputViewer.SetValue(cSharpCode);
        }

        async Task ShowRun()
        {
            var oldOut = Console.Out;
            var cts = new CancellationTokenSource();
            var consoleStream = new StringWriter();
            Task consoleLoop = BackgroundLoop(consoleStream, cts.Token);
            Console.SetOut(consoleStream);
            outputEditorOptions.Language = string.Empty;
            await OutputViewer!.UpdateOptions(outputEditorOptions);
            try
            {
                ScriptingEngine.InlineExecute(code);
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
            cts.Cancel();
            await consoleLoop;
            await OutputViewer!.SetValue(consoleStream.ToString());
            Console.SetOut(oldOut);
        }
    }

    private async Task BackgroundLoop(StringWriter stringWriter, CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            await OutputViewer!.SetValue(stringWriter.ToString());
            try
            {
                await Task.Delay(50, cancellationToken);
            }
            catch (TaskCanceledException) { }
        }
    }
}
