<!DOCTYPE html>
<html>
<body>

{{func render_message(message)}}
    <svg
        x="{{message.RelativeStartPercentage * 100}}%"
        y="0"
        width="{{message.RelativeSpanPercentage * 100}}%"
        height="100%">
        <rect
            x="0"
            y="{{message.Height * 30}}px"
            width="100%"
            height="30px"
            rx="5"
            ry="5"
            fill="hsl({{120 - 120 * message.RelativeSpanPercentage}}, 100%, 50%)"
            onmouseover="onEventHover(this)"
            onclick="onEventClick(this)"
            class="event-rect" />
        <text
            x="50%"
            y="{{message.Height * 30 + 15}}px"
            dominant-baseline="middle"
            text-anchor="middle"
            fill="black"
            class="event-name">
            {{message.Message}}
        </text>
        {{for $child in message.Children}}
            {{render_message($child)}}
        {{end}}
    </svg>
{{end}}

<svg width="1280" height="720" xmlns="http://www.w3.org/2000/svg" id="root-svg">
    {{for $thread in Threads}}
        {{render_message($thread.Root)}}
    {{end}}

    <text
        x="0"
        y="100%"
        text-anchor="start"
        alignment-baseline="baseline"
        fill="black"
        id="hovered-event-text"
        class="event-name" />

    <style>
        .event-name {
            pointer-events: none;
        }

        .event-rect:hover {
            filter: opacity(80%);
        }
    </style>

    <script>
        const rootSvg = document.getElementById("root-svg");

        const markedSet = new Set();
        let undoList = [];

        let horizontalScale = 1;
        let horizontalOffset = 0;

        rootSvg.addEventListener('wheel', (e) => {
            e.preventDefault();

            const scaleFactor = 1.2;
            const delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
            const scale = delta > 0 ? scaleFactor : 1 / scaleFactor;

            const offsetPercentage = (e.clientX - horizontalOffset) / (1280 * horizontalScale);
            horizontalOffset -= offsetPercentage * 1280 * (scale - 1) * horizontalScale;
            horizontalScale *= scale;

            rootSvg.setAttribute("width", horizontalScale * 1280);
            rootSvg.setAttribute("transform", `translate(${horizontalOffset} 0)`);
        });

        function onEventHover(rect) {
            const hoveredText = document.getElementById("hovered-event-text");
            hoveredText.textContent = rect.nextElementSibling.textContent;
        }

        function onEventClick(rect) {
            const group = rect.parentElement;

            markedSet.clear();
            for (const undo of undoList) {
                undo();
            }
            undoList = [];

            maximizeChain(group);
        }

        function markGroupSvg(group) {
            if (!group) return false;
            if (markedSet.has(group)) return false;
            markedSet.add(group);
            return group.tagName === "svg" &amp;&amp; group.id !== "root-svg";
        }

        function addToUndo(group) {
            const oldX = group.getAttribute("x");
            const oldWidth = group.getAttribute("width");

            undoList.push(() => {
                group.setAttribute("x", oldX);
                group.setAttribute("width", oldWidth);
            });
        }

        function maximizeChain(group) {
            if (!markGroupSvg(group)) return;

            maximizeGroup(group);
            maximizeChain(group.parentElement);
            minimizeAround(group);
        }

        function maximizeGroup(group) {
            addToUndo(group);

            group.setAttribute("x", "0");
            group.setAttribute("width", "100%");
        }

        function minimizeAround(group) {
            minimizeChainLeft(group.previousElementSibling);
            minimizeChainRight(group.nextElementSibling);
        }

        function minimizeChainLeft(group) {
            if (!markGroupSvg(group)) return;

            minimizeGroup(group);
            minimizeChainLeft(group.previousElementSibling);
            minimizeChainLeft(group.parentElement);
        }

        function minimizeChainRight(group) {
            if (!markGroupSvg(group)) return;

            minimizeGroup(group);
            minimizeChainRight(group.nextElementSibling);
            minimizeChainRight(group.parentElement);
        }

        function minimizeGroup(group) {
            addToUndo(group);

            group.setAttribute("width", "0%");
        }
    </script>
</svg>

</body>
</html>
